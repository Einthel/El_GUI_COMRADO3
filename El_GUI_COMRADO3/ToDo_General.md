# Список задач (To-Do List)

- [ ] **Окно выбора иконок:**
    - [ ] Разработать UI для окна выбора иконок с сеткой миниатюр.
    - [ ] Реализовать логику загрузки и отображения иконок из папки `icons/`.
    - [ ] Интегрировать новое окно в редактор кнопок (`editor.py`).

- [ ] **Рефакторинг и Архитектура:**
    - [ ] Почистить код от дублей.
    - [ ] Объединить и унифицировать механизмы сохранения (иконки, кнопки, виджеты).
    - [ ] Переработать временный стиль для `SettingsWindow` на постоянный.
    - [ ] Выяснить и исправить иерархию на главной странице в панели кнопок.

- [ ] **Новый функционал:**
    - [ ] Создать модуль/плагин для управления Bluetooth-устройствами (с API).
    - [ ] Реализовать новые действия в редакторе кнопок:
        - [ ] Открытие сайтов.
        - [ ] Выполнение макросов.
            - *Пример сценария для макроса: сделать скриншот, нажать кнопку, после чего открывается браузер и выполняется поиск по картинке из буфера обмена.*

- [ ] **Улучшения UX/UI в Редакторе Панели (`Editor_bar.py`):**
    - [ ] Убрать возможность перетаскивать виджеты *после* того, как они уже были помещены в слот.
    - [ ] Добавить возможность перетаскивать виджет на уже занятый слот (реализовать обмен виджетами).

- [ ] **Исправление багов:**
    - [ ] Исправить баг: при смене иконки уже готовой кнопки иконка не меняется.
    - [ ] Исправить проблему: при переключении с кнопки на кнопку в режиме редактора не сбрасываются выбранные действия кнопки.

---

## Интеграция управления RGB

Интеграция с OpenRGB позволит управлять подсветкой ПК прямо с панели.

### Требования:
- Установленное и **запущенное** приложение OpenRGB с активированным SDK-сервером.
- Установленная в Python-окружение библиотека `openrgb-python`.

### План интеграции

#### Шаг 1: Создание модуля для управления подсветкой (`rgb_manager.py`)
- **Задача:** Создать класс-обертку `RGBManager` для изоляции логики работы с библиотекой `openrgb-python`.
- **Реализация:**
    - При инициализации класс должен пытаться подключиться к SDK-серверу OpenRGB.
    - **Обработка ошибок:** Если сервер не найден, подключение должно проваливаться "тихо", без падения приложения, с установкой внутреннего флага `is_connected = False`.
    - **Методы:**
        - `turn_off_all_lights()`: Выключает всю подсветку (`client.clear()`).
        - `apply_profile(profile_name)`: Загружает профиль OpenRGB по имени (`client.load_profile()`).

#### Шаг 2: Расширение `action_button.py`
- **Задача:** Добавить новые действия для кнопок.
- **Реализация:**
    - Интегрировать `RGBManager`.
    - Добавить методы `rgb_turn_off()` и `rgb_apply_profile(profile_name)`, которые будут вызывать соответствующие методы из `RGBManager`.

#### Шаг 3: Обновление конфигурации и констант
- **Задача:** Определить, как новые действия будут храниться в `config.json`.
- **Реализация:**
    - В `constants.py` добавить `ACTION_TYPE_OPENRGB = "openrgb"`.
    - **Структура в `config.json`:**
        - Выключение: `{ "type": "openrgb", "value": { "command": "off" } }`
        - Профиль: `{ "type": "openrgb", "value": { "command": "profile", "profile_name": "MyProfile" } }`

#### Шаг 4: Модификация редактора кнопок (`editor.py` и `Editor.ui`)
- **Задача:** Добавить в интерфейс редактора возможность настраивать RGB-кнопки.
- **Реализация:**
    - **UI (`Editor.ui`):**
        - Добавить "OpenRGB" в выпадающий список типов действий.
        - Создать новую скрытую панель для настроек OpenRGB.
        - На панели разместить `QComboBox` ("Выключить подсветку" / "Применить профиль") и `QLineEdit` для имени профиля.
    - **Логика (`editor.py`):**
        - Реализовать динамическое отображение/скрытие панели и поля для имени профиля.
        - Обновить логику сохранения (`save_action`) и загрузки (`load_button_config`) для нового типа действия.

#### Шаг 5: Обновление обработчика действий (`comrado3.py`)
- **Задача:** Научить приложение выполнять новые RGB-команды.
- **Реализация:**
    - В `ActionHandler.handle_button_action` добавить обработку `ACTION_TYPE_OPENRGB`.
    - В зависимости от `"command"` вызывать `rgb_turn_off()` или `rgb_apply_profile()`.

#### Шаг 6: Завершение
- **Задача:** Обновить документацию и зависимости.
- **Реализация:**
    - Добавить `openrgb-python` в `requirements.txt`.
    - Упомянуть новую функцию и требование о запущенном OpenRGB в `README.md`.

---

## Интеграция управления Ambient (HyperHDR)

### Краткое резюме

Этот модуль обеспечит интеграцию приложения с системой фоновой подсветки HyperHDR. Управление будет осуществляться через JSON API, что позволит отправлять команды напрямую из `El_GUI_COMRADO3`. Архитектура будет построена по гибкому, data-driven принципу: логика будет отделена в специальный модуль `ambient_control.py`, а конкретные параметры команд (например, имя эффекта или цвет) будут настраиваться пользователем в редакторе и храниться в `config.json`.

### Функционал
- Отправка команд в HyperHDR для управления фоновой подсветкой.
- Настройка кнопок для выполнения следующих действий:
    - Включение/выключение подсветки.
    - Активация любого эффекта по его имени.
    - Установка любого сплошного цвета.
- Гибкая настройка через редактор кнопок без необходимости изменять исходный код.

### Подробный план реализации (Гибкая архитектура)

#### Шаг 1: Создание модуля `ambient_control.py`
- **Задача:** Создать класс `HyperHDRClient`, инкапсулирующий всю логику отправки команд.
- **Реализация:**
    - Использовать библиотеку `requests` для отправки POST-запросов.
    - **`__init__(self, host, port, token)`**: Конструктор для данных подключения.
    - **`_send_request(self, payload)`**: Приватный метод для отправки JSON-запросов с обработкой ошибок соединения.
    - **Публичные методы:** `clear_all()`, `set_effect(effect_name)`, `set_color(r, g, b)`.

#### Шаг 2: Обновление конфигурации и констант
- **Задача:** Добавить настройки подключения и новый тип действия.
- **Реализация:**
    - В `config.json` добавить секцию `"hyperhdr_settings": { "host": "...", "port": ..., "token": "..." }`.
    - В `constants.py` добавить `ACTION_TYPE_HYPERHDR = "hyperhdr"`.

#### Шаг 3: Интеграция в `action_button.py`
- **Задача:** Создать универсальный метод для выполнения команд.
- **Реализация:**
    - В `ButtonActions.__init__` создать экземпляр `HyperHDRClient` на основе данных из `config.json`.
    - Добавить **один** метод `execute_hyperhdr_command(self, params: dict)`, который будет парсить словарь `params` и вызывать соответствующий метод у `hyperhdr_client`.

#### Шаг 4: Обновление `comrado3.py`
- **Задача:** Связать нажатие кнопки с выполнением новой команды.
- **Реализация:**
    - В `ActionHandler.handle_button_action` добавить обработку `ACTION_TYPE_HYPERHDR`.
    - Этот блок должен вызывать `self.button_actions.execute_hyperhdr_command(action_value)`.

#### Шаг 5: Модификация редактора (`editor.py` и `Editor.ui`)
- **Задача:** Создать UI для настройки команд HyperHDR.
- **Реализация:**
    - **UI (`Editor.ui`):**
        - Добавить "HyperHDR" в `Action_type_comboBox`.
        - Создать новую скрытую панель с элементами:
            - `QComboBox` для выбора команды ("Выключить", "Эффект", "Цвет").
            - `QLineEdit` для ввода имени эффекта.
            - `QPushButton` для вызова `QColorDialog` для выбора цвета.
    - **Логика (`editor.py`):**
        - Реализовать динамическое отображение нужных полей ввода в зависимости от выбранной команды.
        - Расширить `save_action()` для сохранения настроек HyperHDR в `config.json` в формате:
          `"action": { "type": "hyperhdr", "value": { "command": "set_effect", "effect_name": "Rainbow swirl" } }`
        - Расширить `load_button_config()` для корректного отображения сохраненных настроек в редакторе.

#### Шаг 6: Завершение
- **Задача:** Обновить документацию и зависимости проекта.
- **Реализация:**
    - Добавить `requests` в `requirements.txt`.
    - В `README.md` и `ToDo_General.md` описать новую функцию и необходимость заполнения `hyperhdr_settings` в `config.json`.

---

## Интеграция управления Deepcool Digital (Системная настройка)

### Краткое резюме (Новая редакция)

Модуль интеграции с Deepcool Digital будет работать как **фоновый сервис** внутри `El_GUI_COMRADO3`. Он будет постоянно считывать выбранные системные показатели (температуру CPU/GPU) и отображать их на дисплее корпуса. Управление тем, **что именно** отображается, будет вынесено в **отдельное окно настроек**, доступное с вкладки "Настройки", а не через систему действий для кнопок. Это превращает функцию из одноразового "действия" в постоянно работающую "системную" возможность.

Интеграция основана на реверс-инжиниринге протокола из проекта [deepcool-digital-linux](https://github.com/Nortank12/deepcool-digital-linux), что позволяет напрямую управлять устройством через USB HID.

### Подробный план реализации

#### Шаг 1: Создание модуля `control_deepcool.py` (Низкоуровневое управление)
- **Задача:** Создать класс `DeepCoolDisplay` для инкапсуляции прямого взаимодействия с USB-устройством.
- **Реализация:**
    - Использовать библиотеку `hidapi` для поиска и подключения к устройству по его Vendor/Product ID.
    - Реализовать методы для отправки отформатированных байтовых пакетов: `connect()`, `disconnect()`, `show_cpu_temp(temp)`, `show_gpu_temp(temp)`, `turn_off()`.

#### Шаг 2: Создание фонового сервиса (`deepcool_service.py`)
- **Задача:** Создать постоянно работающий поток, который будет собирать данные и обновлять дисплей.
- **Реализация:**
    - Создать новый файл `deepcool_service.py` с классом `DeepCoolUpdateService` (на основе `QThread` или `threading.Thread`).
    - В основном цикле сервиса (`run()`):
        1. Считать настройки (режим, интервал) из `config.json`.
        2. Получить актуальные данные о температуре/загрузке с помощью `psutil` и др.
        3. Вызвать соответствующий метод у `DeepCoolDisplay`.
        4. Сделать паузу согласно интервалу.
    - Сервис должен запускаться один раз при старте `main.py`.

#### Шаг 3: Создание окна настроек (`deepcool_settings.ui` и `deepcool_settings.py`)
- **Задача:** Создать UI для управления фоновым сервисом.
- **Реализация:**
    - **UI (`deepcool_settings.ui`):** Спроектировать новое окно с `QComboBox` для выбора режима ("Температура CPU", "Выключен" и т.д.), `QSpinBox` для интервала и кнопками "Применить"/"Отмена".
    - **Логика (`deepcool_settings.py`):** Создать класс окна `DeepCoolSettingsWindow`, который будет загружать UI, читать/сохранять настройки в `config.json` по нажатию кнопок.

#### Шаг 4: Интеграция в основной интерфейс
- **Задача:** Обеспечить доступ к новому окну настроек.
- **Реализация:**
    - **`comrado3.ui`:** На вкладку `_3Settings_tab` добавить кнопку "Настроить дисплей корпуса".
    - **`comrado3.py`:** Подключить сигнал `clicked` от новой кнопки к слоту, который создает и отображает `DeepCoolSettingsWindow`.

#### Шаг 5: Обновление `config.json`
- **Задача:** Определить структуру для хранения настроек сервиса.
- **Реализация:**
    - Создать новый корневой объект:
      `"deepcool_display_settings": { "enabled": true, "mode": "cpu_temp", "update_interval_sec": 1 }`

#### Шаг 6: Завершение
- **Задача:** Обновить документацию и зависимости.
- **Реализация:**
    - Добавить `hidapi` и `psutil` в `requirements.txt`.
    - В `README.md` описать новую функцию и требование об удалении официального ПО DeepCool.

---

## Интеграция мониторинга системы (PyHardwareMonitor)

### Краткое резюме

Этот функционал позволит в реальном времени отображать данные с различных датчиков ПК (CPU, GPU и т.д.) на главной странице приложения. Для этого будет использоваться библиотека `PyHardwareMonitor`, работающая как Python-обертка над `LibreHardwareMonitorLib`. Реализация будет построена на многопоточной архитектуре для сохранения отзывчивости интерфейса.

### Требования:
- Установленная в Python-окружение библиотека `HardwareMonitor` (`pip install HardwareMonitor`).
- **Запуск приложения от имени администратора** для доступа ко всем датчикам.
- (Опционально, но рекомендуется) Установленный драйвер `PawnIO` (`winget install PawnIO`) для доступа к датчикам материнской платы.

### Подробный план реализации

#### Шаг 1: Создание модуля `control_hwinfo.py` (Сборщик данных)
- **Задача:** Создать класс `HwInfoReader`, отвечающий за сбор данных с датчиков в отдельном потоке.
- **Реализация:**
    - Класс должен наследоваться от `QObject` для использования сигналов.
    - **Сигналы:** Определить сигнал `cpu_data_updated = Signal(dict)`, который будет передавать словарь с данными о процессоре.
    - **Методы:**
        - `__init__()`: Инициализация `Computer` из `PyHardwareMonitor` с включением необходимых компонентов (`IsCpuEnabled = True`).
        - `run_monitoring()`: Основной цикл, который будет выполняться в потоке. Внутри него:
            1. Обновление данных с датчиков (`computer.Accept(UpdateVisitor())`).
            2. Вызов метода парсинга данных.
            3. Пауза в 1-2 секунды (`time.sleep()`).
        - `_parse_sensor_data()`: Метод для обхода дерева устройств и извлечения конкретных значений (температура, загрузка, частота, мощность, имя) для CPU. Собранные данные упаковываются в словарь.
        - `stop()`: Метод для корректной остановки потока.

#### Шаг 2: Интеграция в основной интерфейс (`comrado3.py`)
- **Задача:** Запустить сборщик данных в отдельном потоке и связать его с GUI.
- **Реализация:**
    - В классе `ActionHandler` (`comrado3.py`):
        1. Создать экземпляр `HwInfoReader` и переместить его в новый `QThread`.
        2. Подключить сигнал `hw_reader.cpu_data_updated` к новому методу-слоту `update_cpu_display`.
        3. Подключить `started` сигнал потока к `hw_reader.run_monitoring` для автоматического запуска.
        4. Запустить поток (`self.hw_thread.start()`).
    - **Создать метод `update_cpu_display(self, data: dict)`:**
        - Этот метод будет принимать словарь с данными от `HwInfoReader`.
        - Он будет обновлять текст в `QLabel` на главной странице, используя полученные данные и точные имена виджетов:
            - `self.ui.value_name_cpu`
            - `self.ui.value_clocks_cpu`
            - `self.ui.value_load_cpu`
            - `self.ui.value_power_cpu`
            - `self.ui.value_temp_cpu`

#### Шаг 3: Корректное завершение потока
- **Задача:** Обеспечить, чтобы поток мониторинга корректно завершался при закрытии приложения.
- **Реализация:**
    - В главном окне (`main.py` или `comrado3.py`) переопределить метод `closeEvent`.
    - В `closeEvent` вызвать `hw_reader.stop()`, затем `hw_thread.quit()` и `hw_thread.wait()` для ожидания завершения потока перед выходом.
